<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>BPNP Map (Demo)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <!-- Leaflet CSS and JS -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://unpkg.com/leaflet-tilelayer-wmts@1.0.0/leaflet-tilelayer-wmts.js"></script>
  <script src="https://unpkg.com/esri-leaflet@3.0.11/dist/esri-leaflet.js"></script>
  <script src="https://unpkg.com/esri-leaflet-vector@3.0.0/dist/esri-leaflet-vector.js"></script>

  <!-- Panel Display-->
  <link rel="stylesheet" href="https://unpkg.com/leaflet-panel-layers/dist/leaflet-panel-layers.min.css" />
  <script src="https://unpkg.com/leaflet-panel-layers/dist/leaflet-panel-layers.min.js"></script>
  
  <!-- Omnivore for KML -->
  <script src="https://unpkg.com/leaflet-omnivore@0.3.4/leaflet-omnivore.min.js"></script>

  <!-- Leaflet Awesome Markers CSS & JS -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet.awesome-markers@2.0.5/dist/leaflet.awesome-markers.css" />
  <script src="https://unpkg.com/leaflet.awesome-markers@2.0.5/dist/leaflet.awesome-markers.js"></script>

  <!-- FontAwesome 6 for better compatibility -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" />

  <style>
    html, body, #map {
      height: 100%;
      margin: 0;
      padding: 0;
    }

    .loading {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(255, 255, 255, 0.95);
      padding: 15px 25px;
      border-radius: 8px;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
      z-index: 10000;
      display: none;
      font-weight: bold;
      font-size: 16px;
      color: #333;
      border: 2px solid #007cba;
    }

    .loading i {
      margin-right: 10px;
      color: #007cba;
    }

    .station-tooltip {
      background: rgba(255, 152, 80, 0.9); 
      color: #fff;
      border-radius: 4px;
      padding: 6px 10px;
      font-size: 13px;
      font-weight: 600;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
      pointer-events: none;
      border: 1px solid rgba(255, 152, 80, 1);
    }

    .sta-tooltip {
      background: rgba(33, 150, 243, 0.9);  
      color: #fff;
      border-radius: 4px;
      padding: 4px 8px;
      font-size: 11px;
      font-weight: 600;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
      pointer-events: none;
      border: 1px solid rgba(33, 150, 243, 1);
    }

    .debug-info {
      position: fixed;
      bottom: 60px;
      left: 10px;
      background: rgba(0, 0, 0, 0.8);
      color: white;
      padding: 8px 12px;
      font-size: 12px;
      border-radius: 4px;
      display: none;
      z-index: 1000;
      max-width: 300px;
      word-wrap: break-word;
    }

    .notification {
      position: fixed;
      top: 20px;
      right: 20px;
      padding: 10px 15px;
      border-radius: 4px;
      z-index: 1000;
      display: none;
      max-width: 300px;
    }

    .notification.success {
      background: rgba(76, 175, 80, 0.9);
      color: white;
    }

    .notification.error {
      background: rgba(244, 67, 54, 0.9);
      color: white;
    }

    .notification.warning {
      background: rgba(255, 193, 7, 0.9);
      color: black;
    }

    /* Custom layer control styles */
    .leaflet-control-layers {
      max-height: 400px;
      overflow-y: auto;
    }
  </style>
</head>
<body>
  <div id="map"></div>
  <div id="loading" class="loading">
    <i class="fas fa-spinner fa-spin"></i>
    <span id="loading-text">Loading...</span>
  </div>
  <div id="debug-info" class="debug-info"></div>
  <div id="notification" class="notification"></div>

  <script>
    // Initialize map
    const map = L.map("map").setView([16.5, 102.5], 8);

    // Configuration
    const CONFIG = {
      DEBUG: true,
      TIMEOUT: 30000,
      FILES: {
        AL_TRACK: 'DATA/AL_Track.kml',
        STATION: 'DATA/Station.kml',
        STATION_NAME: 'DATA/Station_Name.kml',
        STA: 'DATA/Sta.kml',
        POLYGON01: 'DATA/Polygon01.kml'
      }
    };

    // Utility functions
    function debugLog(message) {
      if (CONFIG.DEBUG) {
        console.log(`[DEBUG] ${message}`);
        const debugDiv = document.getElementById('debug-info');
        debugDiv.textContent = message;
        debugDiv.style.display = 'block';
        setTimeout(() => debugDiv.style.display = 'none', 4000);
      }
    }

    function showNotification(message, type = 'success') {
      const notification = document.getElementById('notification');
      notification.textContent = message;
      notification.className = `notification ${type}`;
      notification.style.display = 'block';
      setTimeout(() => notification.style.display = 'none', 5000);
    }

    // Enhanced loading state management
    const loadingManager = {
      states: {
        alTrack: false,
        stationLayout: false,
        stationName: false,
        showSTA: false,
        polygon01: false
      },
      
      updateState(layerName, isLoading) {
        const normalizedName = layerName.replace(/\s+/g, '').toLowerCase();
        const stateKey = {
          'altrack': 'alTrack',
          'stationlayout': 'stationLayout',
          'stationname': 'stationName',
          'showsta': 'showSTA',
          'polygon01': 'polygon01'
        }[normalizedName];
        
        if (stateKey && this.states.hasOwnProperty(stateKey)) {
          this.states[stateKey] = isLoading;
          this.updateUI();
        }
      },
      
      updateUI() {
        const isAnyLoading = Object.values(this.states).some(state => state);
        const loadingDiv = document.getElementById("loading");
        
        if (isAnyLoading) {
          loadingDiv.style.display = "block";
          const activeLoading = Object.entries(this.states)
            .filter(([key, value]) => value)
            .map(([key]) => key);
          document.getElementById('loading-text').textContent = 
            `Loading ${activeLoading.join(', ')}...`;
        } else {
          loadingDiv.style.display = "none";
        }
        
        if (CONFIG.DEBUG) {
          console.log('Loading states:', this.states);
        }
      }
    };

    // Base map layers
    const baseMaps = {
      "OpenStreetMap": L.tileLayer(
        "https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png",
        {
          maxZoom: 18,
          attribution: "&copy; OpenStreetMap contributors",
        }
      ),
      "Google Satellite": L.tileLayer(
        "https://mt1.google.com/vt/lyrs=s&x={x}&y={y}&z={z}",
        {
          maxZoom: 20,
          attribution: "&copy; Google",
        }
      ),
      "Google Streets": L.tileLayer(
        "https://mt1.google.com/vt/lyrs=m&x={x}&y={y}&z={z}",
        {
          maxZoom: 20,
          attribution: "&copy; Google",
        }
      ),
      "Google Terrain": L.tileLayer(
        "https://mt1.google.com/vt/lyrs=p&x={x}&y={y}&z={z}",
        {
          maxZoom: 20,
          attribution: "&copy; Google",
        }
      ),
      "Satellite (Esri)": L.tileLayer(
        "https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}",
        {
          maxZoom: 18,
          attribution: "&copy; Esri"
        }
      )
    };

    // Add default base map
    baseMaps["OpenStreetMap"].addTo(map);

    // Layer groups
    const layers = {
      alTrack: L.layerGroup(),
      stationLayout: L.layerGroup(),
      stationName: L.layerGroup(),
      showSTA: L.layerGroup(),
      polygon01: L.layerGroup()
    };

    // Loading flags
    const loadingFlags = {
      alTrack: false,
      stationLayout: false,
      stationName: false,
      showSTA: false,
      polygon01: false
    };

    // Enhanced icon management with fallback
    const iconManager = {
      icons: {
        station: {
          iconUrl: 'img/train (blue).png',
          iconSize: [32, 32],
          iconAnchor: [16, 32],
          popupAnchor: [0, -32]
        },
        stop: {
          iconUrl: 'img/train (orange).png',
          iconSize: [32, 32],
          iconAnchor: [16, 32],
          popupAnchor: [0, -32]
        },
        origin: {
          iconUrl: 'img/train (gray).png',
          iconSize: [32, 32],
          iconAnchor: [16, 32],
          popupAnchor: [0, -32]
        },
        default: {
          iconUrl: 'img/train (green).png',
          iconSize: [32, 32],
          iconAnchor: [16, 32],
          popupAnchor: [0, -32]
        }
      },
      
      getIcon(styleUrl) {
        const iconConfig = this.icons[styleUrl] || this.icons.default;
        try {
          return L.icon(iconConfig);
        } catch (error) {
          console.warn(`Failed to load icon for ${styleUrl}, using default marker`);
          return L.divIcon({
            html: `<i class="fas fa-train" style="color: #007cba;"></i>`,
            iconSize: [20, 20],
            className: 'custom-div-icon'
          });
        }
      }
    };

    // Enhanced loader with better error handling
    class LayerLoader {
      constructor(name, file, layer, styleConfig = {}) {
        this.name = name;
        this.file = file;
        this.layer = layer;
        this.styleConfig = styleConfig;
        this.isLoaded = false;
      }

      load() {
        if (this.isLoaded) {
          debugLog(`${this.name} already loaded`);
          return Promise.resolve();
        }

        return new Promise((resolve, reject) => {
          loadingManager.updateState(this.name, true);
          debugLog(`Loading ${this.name}...`);

          const timeoutId = setTimeout(() => {
            loadingManager.updateState(this.name, false);
            const error = new Error(`${this.name} loading timeout`);
            showNotification(`${this.name} loading timeout`, 'error');
            reject(error);
          }, CONFIG.TIMEOUT);

          omnivore.kml(this.file)
            .on("ready", (data) => {
              clearTimeout(timeoutId);
              this.processLayers(data);
              this.isLoaded = true;
              loadingManager.updateState(this.name, false);
              showNotification(`${this.name} loaded successfully`, 'success');
              resolve();
            })
            .on("error", (err) => {
              clearTimeout(timeoutId);
              console.error(`Error loading ${this.name}:`, err);
              loadingManager.updateState(this.name, false);
              showNotification(`Error loading ${this.name}`, 'error');
              reject(err);
            });
        });
      }

      processLayers(data) {
        let processedCount = 0;
        let errorCount = 0;

        data.eachLayer((layer) => {
          try {
            if (this.name === 'Station Name') {
              this.processStationNameLayer(layer);
            } else if (this.name === 'Show STA') {
              this.processSTALayer(layer);
            } else {
              this.processGenericLayer(layer);
            }
            processedCount++;
          } catch (error) {
            errorCount++;
            console.error(`Error processing layer in ${this.name}:`, error);
          }
        });

        debugLog(`${this.name} processed: ${processedCount} layers, ${errorCount} errors`);
      }

      processStationNameLayer(layer) {
        const { name, styleUrl, coords } = this.extractLayerData(layer);
        
        if (coords && name) {
          const cleanStyleUrl = styleUrl ? styleUrl.replace('#', '') : 'default';
          const icon = iconManager.getIcon(cleanStyleUrl);
          
          const marker = L.marker(coords, { icon })
            .bindTooltip(name, {
              permanent: true,
              direction: "top",
              offset: [0, -10],
              className: "station-tooltip",
            });
          
          this.layer.addLayer(marker);
        }
      }

      processSTALayer(layer) {
        const { name, coords } = this.extractLayerData(layer);
        
        if (coords && name) {
          const marker = L.circleMarker(coords, {
            radius: 4,
            color: '#2196f3',
            fillColor: '#2196f3',
            fillOpacity: 0.8,
            weight: 2
          })
          .bindTooltip(name, {
            permanent: false,
            direction: "top",
            offset: [0, -10],
            className: "sta-tooltip",
          })
          .bindPopup(`
            <div style="text-align: center;">
              <strong>Station ${name}</strong><br>
              <small>Coordinates: ${coords[0].toFixed(6)}, ${coords[1].toFixed(6)}</small>
            </div>
          `);
          
          this.layer.addLayer(marker);
        }
      }

      processGenericLayer(layer) {
        if (layer.setStyle && this.styleConfig) {
          layer.setStyle(this.styleConfig);
        }
        this.layer.addLayer(layer);
      }

      extractLayerData(layer) {
        let name = null;
        let styleUrl = null;
        let coords = null;

        if (layer.feature && layer.feature.properties) {
          const props = layer.feature.properties;
          name = props.name || props.Name;
          styleUrl = props.styleUrl;
          
          if (layer.feature.geometry && layer.feature.geometry.coordinates) {
            const geomCoords = layer.feature.geometry.coordinates;
            coords = [geomCoords[1], geomCoords[0]];
          }
        }

        if (!coords && layer.getLatLng) {
          coords = layer.getLatLng();
        }

        return { name, styleUrl, coords };
      }
    }

    // Create layer loaders
    const layerLoaders = {
      alTrack: new LayerLoader('AL Track', CONFIG.FILES.AL_TRACK, layers.alTrack, 
        { color: "red", weight: 2 }),
      stationLayout: new LayerLoader('Station Layout', CONFIG.FILES.STATION, layers.stationLayout, 
        { color: "gray", weight: 1 }),
      stationName: new LayerLoader('Station Name', CONFIG.FILES.STATION_NAME, layers.stationName),
      showSTA: new LayerLoader('Show STA', CONFIG.FILES.STA, layers.showSTA),
      polygon01: new LayerLoader('Polygon01', CONFIG.FILES.POLYGON01, layers.polygon01, 
        { color: "orange", weight: 2, fillColor: "yellow", fillOpacity: 0.8 })
    };

    // Layer control overlays
    const overlays = {
      "AL Track KKNK (red)": layers.alTrack,
      "Station Layout (gray)": layers.stationLayout,
      "Station Name (train icon)": layers.stationName,
      "Show STA (blue dots)": layers.showSTA,
      "Show ROW (yellow/orange)": layers.polygon01,
    };

    // Use panel layers control (more modern)
    const panelLayers = new L.Control.PanelLayers(baseMaps, overlays, {
      collapsibleGroups: true,
      compact: true
    });
    map.addControl(panelLayers);

    // Layer event handlers
    map.on("overlayadd", (e) => {
      const layerMap = {
        "AL Track KKNK (red)": 'alTrack',
        "Station Layout (gray)": 'stationLayout',
        "Station Name (train icon)": 'stationName',
        "Show STA (blue dots)": 'showSTA',
        "Show ROW (yellow/orange)": 'polygon01'
      };

      const layerKey = layerMap[e.name];
      if (layerKey && layerLoaders[layerKey]) {
        layerLoaders[layerKey].load().catch(error => {
          console.error(`Failed to load ${e.name}:`, error);
        });
      }
    });

    // Initialize with AL Track
    layerLoaders.alTrack.load().then(() => {
      layers.alTrack.addTo(map);
      
      // Fit map to AL Track bounds
      try {
        const bounds = layers.alTrack.getBounds();
        if (bounds.isValid()) {
          map.fitBounds(bounds);
        }
      } catch (error) {
        console.warn('Could not fit bounds to AL Track:', error);
      }
    });

    // Add controls
    L.control.scale({
      metric: true,
      imperial: false,
      position: "bottomleft",
    }).addTo(map);

    // Move zoom control to top left
    map.removeControl(map.zoomControl);
    L.control.zoom({
      position: "topleft",
    }).addTo(map);

    // Debug click handler
    if (CONFIG.DEBUG) {
      map.on("click", (e) => {
        debugLog(`Clicked at: ${e.latlng.lat.toFixed(4)}, ${e.latlng.lng.toFixed(4)}`);
      });
    }

    // File accessibility check
    function checkFileAccess() {
      Object.values(CONFIG.FILES).forEach(file => {
        fetch(file, { method: 'HEAD' })
          .then(response => {
            if (!response.ok) {
              debugLog(`File ${file} not accessible (${response.status})`);
            }
          })
          .catch(error => {
            debugLog(`File ${file} check failed: ${error.message}`);
          });
      });
    }

    // Library check
    function checkLibraries() {
      const requiredLibraries = [
        { name: 'Leaflet', check: () => typeof L !== 'undefined' },
        { name: 'Omnivore', check: () => typeof omnivore !== 'undefined' },
        { name: 'PanelLayers', check: () => typeof L.Control.PanelLayers !== 'undefined' }
      ];

      requiredLibraries.forEach(lib => {
        if (!lib.check()) {
          console.error(`${lib.name} library not loaded!`);
          showNotification(`${lib.name} library missing`, 'error');
        }
      });
    }

    // Initialize on load
    window.addEventListener('load', () => {
      checkFileAccess();
      checkLibraries();
      debugLog('Map initialized successfully');
    });

    // Global error handler
    window.addEventListener("error", (e) => {
      console.error("Global error:", e.error);
      showNotification(`Error: ${e.error.message}`, 'error');
    });
  </script>
</body>
</html>
